using System.Collections.Generic;
using UnityEngine;
using DG.Tweening;
using TMPro;

public class CardEnter : MonoBehaviour
{
    [Header("【卡牌引用】")]
    [SerializeField] private List<SpriteRenderer> listPokers;
    [SerializeField] private List<TMP_Text> listTips;

    [Header("【左侧/弃牌区 UI 引用】")]
    [SerializeField] private List<SpriteRenderer> listLeftPokers;
    [SerializeField] private SpriteRenderer discardCard;
    [SerializeField] private Transform recallButton;

    // ====== 主卡牌动画参数 ======
    [Header("主卡牌动画参数")]
    [SerializeField] private float animationDuration;
    [SerializeField] private Vector3 startOffset;
    [SerializeField] private float batchDelay;

    // ====== 左侧牌区参数 ======
    [Header("左侧牌区参数")]
    [Tooltip("左侧牌堆的本地起始锚点（1L卡牌的位置）。")]
    [SerializeField] private Vector3 leftStackStartPosition;
    [SerializeField] private float leftCardXOffset;
    [SerializeField] private float leftAnimationDuration;
    [SerializeField] private float recallButtonFadeDelay;

    [HideInInspector]
    public int cardLength;
    private Vector3[] targetPositions = new Vector3[18];

    private void Awake()
    {
        cardLength = listPokers.Count;
        RecordAndHideCards();
        InitializeLeftArea();
        InitializeDiscardArea();
        InitializeRecallButton();
    }

    private void Start()
    {
        StartEnterAnimationSequence();
    }


    public TMP_Text GetTipByIndex(int index)
    {
        if (index >= 0 && index < listTips.Count)
        {
            return listTips[index];
        }
        return null;
    }

    /// <summary>
    /// 计算弃牌区卡牌的本地目标位置。Y 轴是左侧牌区的对齐基准。
    /// </summary>
    private Vector3 GetDiscardTargetPosition()
    {
        // 这些值来自您在 CardInteractionManager 中定义的弃牌堆基准坐标
        const float FIXED_TARGET_X = 1.97f;
        const float FIXED_TARGET_Y = -4.1f;
        float targetZ = leftStackStartPosition.z;
        return new Vector3(FIXED_TARGET_X, FIXED_TARGET_Y, targetZ);
    }

    /// <summary>
    /// 计算左侧牌的本地目标位置。Y轴与弃牌堆平行。
    /// </summary>
    private Vector3 GetLeftPokerTargetPosition(int index)
    {
        // 【关键修改】：获取弃牌堆的Y坐标作为对齐基准
        float fixedTargetY = GetDiscardTargetPosition().y;

        float targetX = leftStackStartPosition.x + index * leftCardXOffset;
        float targetZ = leftStackStartPosition.z;

        return new Vector3(targetX, fixedTargetY, targetZ);
    }

    /// <summary>
    /// 记录主卡牌目标位置（Scene中设定的位置）并瞬移到屏幕外起始点。
    /// </summary>
    private void RecordAndHideCards()
    {
        float sumX = 0f;
        float sumZ = 0f;
        for (int i = 0; i < listPokers.Count; i++)
        {
            // 【关键修改】：恢复目标位置为 Scene 中设定的位置
            targetPositions[i + 1] = listPokers[i].transform.position;

            sumX += targetPositions[i + 1].x;
            sumZ += targetPositions[i + 1].z;
        }

        if (cardLength == 0) return;
        float avgX = sumX / cardLength;
        float avgZ = sumZ / cardLength;

        // 使用第一个卡牌的 Y 轴作为基准
        float baseSceneY = listPokers[0].transform.position.y;
        Vector3 centralEntryPosition = new Vector3(avgX, baseSceneY + startOffset.y, avgZ);

        for (int i = 0; i < listPokers.Count; i++)
        {
            Transform cardTransform = listPokers[i].transform;
            cardTransform.position = centralEntryPosition; // 世界坐标
            cardTransform.localEulerAngles = new Vector3(90f, 90f, 0f);
            listPokers[i].color = new Color(1, 1, 1, 0); // 隐藏卡牌
        }
    }

    /// <summary>
    /// 初始化左侧牌区的本地起始位置和状态。
    /// </summary>
    private void InitializeLeftArea()
    {
        if (listLeftPokers == null || listLeftPokers.Count == 0) return;

        // 降低起始 Y 轴的偏移量，防止卡牌从屏幕外太低的位置飞入
        const float INITIAL_Y_OFFSET = 5f;

        for (int i = 0; i < listLeftPokers.Count; i++)
        {
            Transform cardTransform = listLeftPokers[i].transform;
            cardTransform.localScale = Vector3.one;

            Vector3 targetPos = GetLeftPokerTargetPosition(i);

            // 【关键修改】：减少 Y 轴偏移量，修正入场只显示一半的问题
            Vector3 startPosLocal = targetPos - new Vector3(0, INITIAL_Y_OFFSET, 0);

            cardTransform.localPosition = startPosLocal;
            cardTransform.localEulerAngles = Vector3.zero;
            listLeftPokers[i].color = new Color(1, 1, 1, 0);
        }
    }

    /// <summary>
    /// 初始化弃牌区卡牌的本地起始位置和状态。
    /// </summary>
    private void InitializeDiscardArea()
    {
        if (discardCard == null) return;

        // 降低起始 Y 轴的偏移量，防止卡牌从屏幕外太低的位置飞入
        const float INITIAL_Y_OFFSET = 5f;

        Transform discardTransform = discardCard.transform;
        discardTransform.localScale = Vector3.one;

        Vector3 targetPos = GetDiscardTargetPosition();

        // 【关键修改】：减少 Y 轴偏移量，修正入场只显示一半的问题
        Vector3 startPosLocal = targetPos - new Vector3(0, INITIAL_Y_OFFSET, 0);

        discardTransform.localPosition = startPosLocal;
        discardTransform.localEulerAngles = Vector3.zero;

        discardCard.color = new Color(1, 1, 1, 0);
    }

    /// <summary>
    /// 初始化回撤按钮：将其设置为完全透明，并禁用其对象。
    /// </summary>
    private void InitializeRecallButton()
    {
        if (recallButton == null) return;

        CanvasGroup cg = recallButton.GetComponent<CanvasGroup>();
        if (cg != null)
        {
            cg.alpha = 0f;
            cg.interactable = false;
            cg.blocksRaycasts = false;
        }

        recallButton.gameObject.SetActive(false);
    }

    /// <summary>
    /// 创建主卡牌的入场动画 (DOMove)。
    /// </summary>
    private Tween CreateCardTween(int cardIndex, float duration)
    {
        Transform cardTransform = listPokers[cardIndex - 1].transform;
        SpriteRenderer cardRenderer = listPokers[cardIndex - 1];
        Vector3 targetPos = targetPositions[cardIndex];

        Sequence cardSequence = DOTween.Sequence();

        Tween moveTween = cardTransform.DOMove(targetPos, duration).SetEase(Ease.OutSine);
        Tween finalRotate = cardTransform.DOLocalRotate(Vector3.zero, duration, RotateMode.Fast).SetEase(Ease.InOutQuad);
        Tween fadeTween = cardRenderer.DOFade(1f, duration * 0.5f);

        cardSequence.Append(moveTween);
        cardSequence.Join(finalRotate);
        cardSequence.Join(fadeTween);

        return cardSequence;
    }

    /// <summary>
    /// 创建左侧牌区的连续堆叠入场动画 (DOLocalMove)。
    /// </summary>
    private Sequence AnimateLeftArea()
    {
        Sequence leftSequence = DOTween.Sequence();
        if (listLeftPokers == null || listLeftPokers.Count == 0) return leftSequence;

        float aggressiveOverlapLeft = -(leftAnimationDuration - 0.1f);

        for (int i = 0; i < listLeftPokers.Count; i++)
        {
            Transform cardTransform = listLeftPokers[i].transform;
            SpriteRenderer cardRenderer = listLeftPokers[i];
            Vector3 targetPos = GetLeftPokerTargetPosition(i);

            Tween moveTween = cardTransform.DOLocalMove(targetPos, leftAnimationDuration).SetEase(Ease.OutBack);
            Tween fadeTween = cardRenderer.DOFade(1f, leftAnimationDuration * 0.5f);

            Sequence cardEntry = DOTween.Sequence().Append(moveTween).Join(fadeTween);

            leftSequence.Append(cardEntry);

            if (i < listLeftPokers.Count - 1)
            {
                leftSequence.AppendInterval(aggressiveOverlapLeft);
            }
        }

        return leftSequence;
    }

    /// <summary>
    /// 创建弃牌区卡牌的入场动画 (DOLocalMove)。
    /// </summary>
    private Tween AnimateDiscardArea()
    {
        if (discardCard == null) return DOTween.Sequence();

        Transform discardTransform = discardCard.transform;
        Vector3 targetPos = GetDiscardTargetPosition();

        Tween moveTween = discardTransform.DOLocalMove(targetPos, leftAnimationDuration).SetEase(Ease.OutBack);
        Tween fadeTween = discardCard.DOFade(1f, leftAnimationDuration * 0.5f);

        return DOTween.Sequence().Append(moveTween).Join(fadeTween);
    }

    /// <summary>
    /// 创建回撤按钮的淡入动画。
    /// </summary>
    private Tween AnimateRecallButton()
    {
        if (recallButton == null) return DOTween.Sequence();

        CanvasGroup cg = recallButton.GetComponent<CanvasGroup>();
        if (cg != null)
        {
            recallButton.gameObject.SetActive(true);

            cg.interactable = false;
            cg.blocksRaycasts = false;

            return cg.DOFade(1f, 0.3f)
                     .OnComplete(() => {
                         cg.interactable = true;
                         cg.blocksRaycasts = true;
                     });
        }
        else
        {
            Debug.LogError("回撤按钮上缺少 CanvasGroup 组件，淡入效果可能失败！");
            return DOTween.Sequence();
        }
    }

    /// <summary>
    /// 启动所有卡牌和 UI 元素的入场动画序列。
    /// </summary>
    private void StartEnterAnimationSequence()
    {
        Sequence enterSequence = DOTween.Sequence();
        float aggressiveOverlap = -(animationDuration - 0.3f);

        // 主卡牌入场序列
        enterSequence.Append(CreateCardTween(1, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(7, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(2, animationDuration)).Join(CreateCardTween(8, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(3, animationDuration)).Join(CreateCardTween(9, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);

        int[] leftSide = { 10, 11, 12, 13 };
        int[] rightSide = { 14, 15, 16, 17 };
        for (int i = 0; i < leftSide.Length; i++)
        {
            enterSequence.Append(CreateCardTween(leftSide[i], animationDuration)).Join(CreateCardTween(rightSide[i], animationDuration));
            enterSequence.AppendInterval(aggressiveOverlap);
        }

        enterSequence.Append(CreateCardTween(4, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(5, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(6, animationDuration));

        // UI 元素入场序列
        enterSequence.AppendInterval(0.8f);
        enterSequence.Append(AnimateLeftArea());
        enterSequence.AppendInterval(0.3f);
        enterSequence.Append(AnimateDiscardArea());
        enterSequence.AppendInterval(recallButtonFadeDelay);
        enterSequence.Append(AnimateRecallButton());

        enterSequence.OnComplete(() =>
        {
            Debug.Log("所有 UI 元素入场动画序列完成！现在可以开始交互操作。");
        });
    }
}

using UnityEngine;
using System.Collections.Generic;
using TMPro; // 引入 TMPro 命名空间

// 卡牌类型
public enum CardType
{
    FieldCard,    // 场内牌 (1~17)
    LeftHandCard, // 左手牌区
}

// 场内牌的逻辑层级
public enum FieldLayer
{
    Top,    // 顶层（先开放）
    Middle, // 中层（次开放）
    Bottom, // 底层（最后开放）
    Stack   // 左手牌堆专用
}

public class CardData : MonoBehaviour
{
    // ====== 数据和逻辑层级 ======

    // 将 Type 恢复为 public
    [SerializeField] public CardType type; // 保留 [SerializeField] 以便在 Inspector 中设置
    // public CardType Type => type; // 可以删除或注释掉这个只读属性

    // 将 Layer 恢复为 public
    [SerializeField] public FieldLayer layer;
    // public FieldLayer Layer => layer; // 可以删除或注释掉这个只读属性

    // 将 Stack Index 恢复为 public
    [SerializeField] public int stackIndex;
    // public int StackIndex => stackIndex; // 可以删除或注释掉这个只读属性

    // 将 BlockerCards 恢复为 public
    [SerializeField] public List<CardData> BlockerCards = new List<CardData>();
    // public List<CardData> BlockerCardsList => BlockerCards; // 可以删除或注释掉这个只读属性
    // ====== Tip 关联和引用 ======

    // Tip 的私有引用（通过代码查找并赋值）
    private TMP_Text cardTip;
    public TMP_Text CardTip => cardTip;

    [Header("【Tip 关联】")]
    [Tooltip("卡牌在 CardEnter.listPokers/listTips 中的 0-based 索引。")]
    [SerializeField] private int listIndex;
    public int ListIndex => listIndex;


    [HideInInspector]
    public Vector3 initialLocalPosition;
    [HideInInspector]
    public Quaternion initialLocalRotation;

    private void Awake()
    {
        RecordInitialState();

        // 尝试获取 CardEnter 实例并设置 Tip
        CardEnter cardEnter = FindObjectOfType<CardEnter>();
        if (cardEnter != null)
        {
            // 通过索引获取 Tip
            cardTip = cardEnter.GetTipByIndex(listIndex);

            // 确保 Tip 的初始 Z 坐标与卡牌主体同步，以防入场动画时 Z 坐标不一致
            if (cardTip != null)
            {
                // 将 Tip 的本地 Z 坐标设置在卡牌主体前一点点，确保初始渲染正确
                cardTip.transform.localPosition = new Vector3(
                    cardTip.transform.localPosition.x,
                    cardTip.transform.localPosition.y,
                    transform.localPosition.z - 0.01f);
            }
        }
    }

    public void RecordInitialState()
    {
        initialLocalPosition = transform.localPosition;
        initialLocalRotation = transform.localRotation;
    }
}

using System.Collections.Generic;
using UnityEngine;
using DG.Tweening;

public class CardInteractionManager : MonoBehaviour
{
    // ====== 引用和参数 ======
    [SerializeField] private Transform recallButton;
    [SerializeField] private float interactionDuration;

    // 弃牌堆的固定世界坐标 (在 Inspector 中设置)
    [SerializeField] private Vector3 discardWorldBasePosition;

    // 堆叠 Z 轴偏移量
    private const float STACK_Z_OFFSET = 0.05f;

    // 状态堆栈：记录被移动的卡牌，用于回撤
    private Stack<CardData> discardStack = new Stack<CardData>();

    // 逻辑层级计数 (如果不在其他地方使用，可以删除)
    private int topLayerCount = 0;
    private int middleLayerCount = 0;

    // 左手牌堆逻辑列表，用于检查顶层卡牌
    private List<CardData> leftStackCards = new List<CardData>();

    // ================== 初始化 (已修复) ==================

    void Start()
    {
        CardData[] allCards = FindObjectsOfType<CardData>();

        foreach (CardData card in allCards)
        {
            card.RecordInitialState();
            card.transform.localScale = Vector3.one;

            // 确保所有卡牌的 Collider 默认禁用，由逻辑控制启用
            Collider cardCollider = card.GetComponent<Collider>();
            if (cardCollider != null)
            {
                cardCollider.enabled = false;
            }


            if (card.type == CardType.FieldCard)
            {
                if (card.layer == FieldLayer.Top) topLayerCount++;
                else if (card.layer == FieldLayer.Middle) middleLayerCount++;
            }
            else if (card.type == CardType.LeftHandCard)
            {
                // 1. 构建左手牌列表
                leftStackCards.Add(card);
            }
        }

        // 2. 排序左手牌列表
        leftStackCards.Sort((a, b) => a.stackIndex.CompareTo(b.stackIndex));

        // 3. 启用初始可点击的卡牌碰撞体
        // 默认情况下，所有 FieldCard 都是可点击的 (因为没有 BlockerCards 挡住它们)
        foreach (CardData card in allCards)
        {
            if (card.type == CardType.FieldCard)
            {
                // FieldCard 默认启用，因为它们可能没有阻挡物
                Collider fieldCollider = card.GetComponent<Collider>();
                if (fieldCollider != null)
                {
                    fieldCollider.enabled = true;
                }
            }
        }

        // 启用左手牌堆的顶层卡牌
        if (leftStackCards.Count > 0)
        {
            CardData topCard = leftStackCards[leftStackCards.Count - 1];
            Collider topCollider = topCard.GetComponent<Collider>();
            if (topCollider != null)
            {
                topCollider.enabled = true; // 启用顶层卡牌的碰撞体
            }
        }

        // 打印调试信息，确认初始顶层卡牌
        if (leftStackCards.Count > 0)
        {
            Debug.Log($"左手牌堆顶层卡牌 '{leftStackCards[leftStackCards.Count - 1].name}' 的 Collider 已启用。");
        }
    }

    // ================== 点击处理 (保持 3D Raycast) ==================

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            HandleClick();
        }
    }

    private void HandleClick()
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out RaycastHit hit))
        {
            CardData card = hit.collider.GetComponent<CardData>();

            if (card != null)
            {
                if (IsCardClickable(card))
                {
                    MoveCardToRightHand(card);
                }
            }
            else if (hit.transform == recallButton)
            {
                if (discardStack.Count > 0)
                {
                    RecallLastCard();
                }
            }
        }
    }

    private bool IsCardClickable(CardData card)
    {
        // 核心检查：碰撞体必须启用
        Collider cardCollider = card.GetComponent<Collider>();
        if (cardCollider == null || !cardCollider.enabled) return false;

        if (card.type == CardType.FieldCard)
        {
            // 场内牌逻辑：检查所有阻挡牌是否已被清除
            foreach (CardData blocker in card.BlockerCards)
            {
                Collider blockerCollider = blocker.GetComponent<Collider>();
                if (blockerCollider != null && blockerCollider.enabled)
                {
                    return false;
                }
            }
            return true;
        }
        else if (card.type == CardType.LeftHandCard)
        {
            // 左手牌逻辑：只有列表中的最后一张（顶层卡牌）可点击
            if (leftStackCards.Count == 0) return false;
            return card == leftStackCards[leftStackCards.Count - 1];
        }

        return false;
    }

    private void MoveCardToRightHand(CardData card)
    {
        if (!IsCardClickable(card)) return;

        // ... (省略目标位置计算和 Tip 逻辑，保持不变) ...
        Transform cardParent = card.transform.parent;
        Vector3 targetBaseLocalPos;

        if (cardParent != null)
        {
            targetBaseLocalPos = cardParent.InverseTransformPoint(discardWorldBasePosition);
        }
        else
        {
            targetBaseLocalPos = discardWorldBasePosition;
        }

        // --- Tip 隐藏逻辑 1：禁用前一张卡牌的 Tip GameObject ---
        if (discardStack.Count > 0)
        {
            CardData previousTopCard = discardStack.Peek();
            if (previousTopCard.CardTip != null && previousTopCard.CardTip.gameObject != null)
            {
                previousTopCard.CardTip.gameObject.SetActive(false);
            }
        }
        // ---------------------------------------------------

        int currentStackCount = discardStack.Count;
        float newZ = targetBaseLocalPos.z + (currentStackCount * STACK_Z_OFFSET);

        Vector3 dynamicTargetLocalPos = new Vector3(
            targetBaseLocalPos.x,
            targetBaseLocalPos.y,
            newZ
        );

        SpriteRenderer cardRenderer = card.GetComponent<SpriteRenderer>();
        if (cardRenderer != null)
        {
            cardRenderer.sortingOrder = currentStackCount;
            cardRenderer.DOFade(1f, 0.1f);
        }

        // --- Tip 文本 Z 轴和可见性修正逻辑 2：处理新卡牌 Tip ---
        if (card.CardTip != null && card.CardTip.gameObject != null)
        {
            card.CardTip.gameObject.SetActive(true);

            Vector3 tipTargetLocalPos = dynamicTargetLocalPos;
            tipTargetLocalPos.z += 0.01f;

            card.CardTip.transform.DOLocalMove(tipTargetLocalPos, interactionDuration)
                .SetEase(Ease.InOutSine);

            card.CardTip.DOFade(1f, 0.1f);
        }
        // -----------------------------------------------------------

        if (card.type == CardType.FieldCard)
        {
            AnimateFieldToDiscard(card.transform, dynamicTargetLocalPos);
        }
        else if (card.type == CardType.LeftHandCard)
        {
            AnimateLeftToDiscard(card.transform, dynamicTargetLocalPos);

            if (leftStackCards.Count > 0)
            {
                leftStackCards.RemoveAt(leftStackCards.Count - 1); // 移除被点击的卡牌
            }
        }

        // 禁用当前卡牌的碰撞体
        Collider cardCollider = card.GetComponent<Collider>();
        if (cardCollider != null)
        {
            cardCollider.enabled = false;
        }

        discardStack.Push(card);

        // ===============================================
        // 启用新的顶层卡牌的碰撞体
        // ===============================================
        if (card.type == CardType.LeftHandCard && leftStackCards.Count > 0)
        {
            CardData newTopCard = leftStackCards[leftStackCards.Count - 1];
            Collider newTopCollider = newTopCard.GetComponent<Collider>();
            if (newTopCollider != null)
            {
                newTopCollider.enabled = true; // 启用新的顶层卡牌
            }
        }
    }

    // ================== 动画定义 (保持不变) ==================
    private void AnimateFieldToDiscard(Transform cardTransform, Vector3 targetLocalPos)
    {
        // ... (保持不变)
        cardTransform.DOLocalMove(targetLocalPos, interactionDuration)
                     .SetEase(Ease.InOutSine)
                     .OnComplete(() => {
                         cardTransform.localScale = Vector3.one;
                     });
    }

    private void AnimateLeftToDiscard(Transform cardTransform, Vector3 targetLocalPos)
    {
        // ... (保持不变)
        Sequence flipAndMove = DOTween.Sequence();
        float halfDuration = interactionDuration * 0.5f;

        Tween finalRotate = cardTransform.DOLocalRotate(new Vector3(0, 180f, 0), halfDuration, RotateMode.Fast)
                                        .SetEase(Ease.InOutQuad);

        flipAndMove.Append(cardTransform.DOLocalMove(targetLocalPos, interactionDuration)
                                        .SetEase(Ease.InOutSine));
        flipAndMove.Join(finalRotate);

        flipAndMove.OnComplete(() =>
        {
            cardTransform.localScale = Vector3.one;
        });
    }

    // ================== 回撤逻辑 ==================
    private void RecallLastCard()
    {
        if (discardStack.Count == 0) return;

        CardData cardToRecall = discardStack.Pop();
        Transform cardTransform = cardToRecall.transform;

        // 目标位置：卡牌的初始本地位置
        Vector3 endLocalPos = cardToRecall.initialLocalPosition;

        // 启用碰撞体 (使用通用 Set 方法)
        Collider recallCollider = cardToRecall.GetComponent<Collider>();
        if (recallCollider != null)
        {
            recallCollider.enabled = true;
        }

        // --- Tip 逻辑 3：隐藏回撤卡牌的 Tip ---
        if (cardToRecall.CardTip != null && cardToRecall.CardTip.gameObject != null)
        {
            cardToRecall.CardTip.gameObject.SetActive(false);
        }

        // --- Tip 逻辑 4：显示新的顶层 Tip (如果存在) ---
        if (discardStack.Count > 0)
        {
            CardData newTopCard = discardStack.Peek();
            if (newTopCard.CardTip != null && newTopCard.CardTip.gameObject != null)
            {
                newTopCard.CardTip.gameObject.SetActive(true);
                newTopCard.CardTip.DOFade(1f, 0.1f);
            }
        }
        // -----------------------------------------

        // 创建动画序列
        Sequence recallSequence = DOTween.Sequence();

        // 动画：移动回初始位置
        recallSequence.Append(
            cardTransform.DOLocalMove(endLocalPos, interactionDuration)
                         .SetEase(Ease.OutBack)
        );

        if (cardToRecall.type == CardType.LeftHandCard)
        {
            // LeftHandCard 回撤时：

            // 1. 恢复旋转：从 180 度转回 0 度（正面朝上）
            Tween reverseRotate = cardTransform.DOLocalRotate(Vector3.zero, interactionDuration, RotateMode.Fast)
                                               .SetEase(Ease.OutSine);
            recallSequence.Join(reverseRotate);

            // 2. 恢复逻辑列表
            leftStackCards.Add(cardToRecall);
            leftStackCards.Sort((a, b) => a.stackIndex.CompareTo(b.stackIndex));
        }
        else if (cardToRecall.type == CardType.FieldCard)
        {
            // FieldCard 回撤时：

            // 1. 恢复缩放 (如果有缩放动画的话，确保它恢复到 1, 1, 1)
            Tween reverseScale = cardTransform.DOScale(1f, interactionDuration);
            recallSequence.Join(reverseScale);

            // 2. 恢复场内牌计数
            if (cardToRecall.layer == FieldLayer.Top) topLayerCount++;
            else if (cardToRecall.layer == FieldLayer.Middle) middleLayerCount++;
        }

        // 最终淡入动画 (所有卡牌)
        cardTransform.GetComponent<SpriteRenderer>().DOFade(1f, 0.2f);

        // 在回撤动画完成后，检查左侧牌堆，禁用新顶层卡牌以外的所有卡牌的 Collider。
        // 注意：这里的 Collider 状态控制由 MoveCardToRightHand 的反向操作保证，
        // 即 MoveCardToRightHand 启用新顶层卡牌，而我们回撤后启用了卡牌本身的 Collider。

    }
}
