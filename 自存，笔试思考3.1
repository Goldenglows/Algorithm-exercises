using UnityEngine;
using System.Collections.Generic;
using TMPro;

// 卡牌类型
public enum CardType
{
    FieldCard,      // 场内牌 (1~17)
    LeftHandCard,   // 左手牌区
}

// 场内牌的逻辑层级
public enum FieldLayer
{
    Top,    // 顶层
    Middle, // 中层
    Bottom, // 底层
}

public class CardData : MonoBehaviour
{
    [Header("【卡牌属性】")]
    [SerializeField] public CardType type;
    [SerializeField] public FieldLayer layer;
    [SerializeField] public int stackIndex; // 用于左手牌堆排序
    [SerializeField] public List<CardData> BlockerCards = new List<CardData>(); // 阻挡此卡牌的卡牌列表

    [Header("【Tip 关联】")]
    [Tooltip("卡牌在 CardEnter.listPokers/listTips 中的 0-based 索引。")]
    [SerializeField] private int listIndex;

    private TMP_Text cardTip;
    public TMP_Text CardTip => cardTip;

    [HideInInspector]
    public Vector3 initialLocalPosition;
    [HideInInspector]
    public Quaternion initialLocalRotation;

    private void Awake()
    {
        // 尝试获取 CardEnter 实例并设置 Tip
        CardEnter cardEnter = FindObjectOfType<CardEnter>();
        if (cardEnter != null)
        {
            // 通过索引获取 Tip
            cardTip = cardEnter.GetTipByIndex(listIndex);

            // 确保 Tip 的初始 Z 坐标与卡牌主体同步
            if (cardTip != null)
            {
                Vector3 tipLocalPos = cardTip.transform.localPosition;
                tipLocalPos.z = transform.localPosition.z - 0.01f;
                cardTip.transform.localPosition = tipLocalPos;
            }
        }
    }

    /// <summary>
    /// 【已修复】由 CardEnter 在入场动画完成后调用，记录卡牌的最终稳定位置和旋转，供回撤时使用。
    /// </summary>
    public void FinalizeInitialState()
    {
        initialLocalPosition = transform.localPosition;
        initialLocalRotation = transform.localRotation;
        Debug.Log($"卡牌 {this.name} 的最终初始位置已记录: {initialLocalPosition}");
    }
}

using System.Collections.Generic;
using UnityEngine;
using DG.Tweening;
using TMPro;

public class CardEnter : MonoBehaviour
{
    [Header("【卡牌引用】")]
    [SerializeField] private List<SpriteRenderer> listPokers;
    [SerializeField] private List<TMP_Text> listTips;

    [Header("【左侧/弃牌区 UI 引用】")]
    [SerializeField] private List<SpriteRenderer> listLeftPokers;
    [SerializeField] private SpriteRenderer discardCard;
    [SerializeField] private Transform recallButton;

    [Header("主卡牌动画参数")]
    [SerializeField] private float animationDuration;
    [SerializeField] private Vector3 startOffset;

    [Header("左侧牌区参数")]
    [Tooltip("左侧牌堆的本地起始锚点（1L卡牌的位置）。")]
    [SerializeField] private Vector3 leftStackStartPosition;
    [SerializeField] private float leftCardXOffset;
    [SerializeField] private float leftAnimationDuration;
    [SerializeField] private float recallButtonFadeDelay;

    private Vector3[] targetPositions = new Vector3[18];
    // 【新增/恢复】用于存储所有卡牌数据引用的列表
    private List<CardData> allCardData = new List<CardData>();

    private void Awake()
    {
        RecordAndHideCards();
        InitializeLeftArea();
        InitializeDiscardArea();
        InitializeRecallButton();
    }

    private void Start()
    {
        CollectAllCardData();
        StartEnterAnimationSequence();
    }

    public TMP_Text GetTipByIndex(int index)
    {
        if (index >= 0 && index < listTips.Count)
        {
            return listTips[index];
        }
        return null;
    }

    /// <summary>
    /// 【新增/恢复】收集所有卡牌 GameObjects 上的 CardData 组件。
    /// </summary>
    private void CollectAllCardData()
    {
        foreach (SpriteRenderer sr in listPokers)
        {
            CardData cd = sr.GetComponent<CardData>();
            if (cd != null) allCardData.Add(cd);
        }
        foreach (SpriteRenderer sr in listLeftPokers)
        {
            CardData cd = sr.GetComponent<CardData>();
            if (cd != null) allCardData.Add(cd);
        }
        if (discardCard != null)
        {
            CardData cd = discardCard.GetComponent<CardData>();
            if (cd != null) allCardData.Add(cd);
        }
    }

    /// <summary>
    /// 计算弃牌区卡牌的本地目标位置。Y 轴是左侧牌区的对齐基准。
    /// </summary>
    private Vector3 GetDiscardTargetPosition()
    {
        const float FIXED_TARGET_X = 1.97f;
        const float FIXED_TARGET_Y = -4.1f;
        float targetZ = leftStackStartPosition.z;
        return new Vector3(FIXED_TARGET_X, FIXED_TARGET_Y, targetZ);
    }

    /// <summary>
    /// 计算左侧牌的本地目标位置。
    /// </summary>
    private Vector3 GetLeftPokerTargetPosition(int index)
    {
        float fixedTargetY = GetDiscardTargetPosition().y;
        float targetX = leftStackStartPosition.x + index * leftCardXOffset;
        float targetZ = leftStackStartPosition.z;
        return new Vector3(targetX, fixedTargetY, targetZ);
    }

    /// <summary>
    /// 记录主卡牌目标位置（Scene中设定的位置）并瞬移到屏幕外起始点。
    /// </summary>
    private void RecordAndHideCards()
    {
        float sumX = 0f;
        float sumZ = 0f;
        for (int i = 0; i < listPokers.Count; i++)
        {
            targetPositions[i + 1] = listPokers[i].transform.position;
            sumX += targetPositions[i + 1].x;
            sumZ += targetPositions[i + 1].z;
        }

        int cardLength = listPokers.Count;
        if (cardLength == 0) return;

        float avgX = sumX / cardLength;
        float avgZ = sumZ / cardLength;
        float baseSceneY = listPokers[0].transform.position.y;
        Vector3 centralEntryPosition = new Vector3(avgX, baseSceneY + startOffset.y, avgZ);

        for (int i = 0; i < listPokers.Count; i++)
        {
            Transform cardTransform = listPokers[i].transform;
            cardTransform.position = centralEntryPosition; // 世界坐标起始点
            cardTransform.localEulerAngles = new Vector3(90f, 90f, 0f); // 初始旋转
            listPokers[i].color = new Color(1, 1, 1, 0); // 隐藏卡牌
        }
    }

    /// <summary>
    /// 初始化左侧牌区的本地起始位置和状态。
    /// </summary>
    private void InitializeLeftArea()
    {
        if (listLeftPokers == null || listLeftPokers.Count == 0) return;
        const float INITIAL_Y_OFFSET = 5f;

        for (int i = 0; i < listLeftPokers.Count; i++)
        {
            Transform cardTransform = listLeftPokers[i].transform;
            Vector3 targetPos = GetLeftPokerTargetPosition(i);
            Vector3 startPosLocal = targetPos - new Vector3(0, INITIAL_Y_OFFSET, 0);

            cardTransform.localPosition = startPosLocal;
            cardTransform.localEulerAngles = Vector3.zero;
            listLeftPokers[i].color = new Color(1, 1, 1, 0);
        }
    }

    /// <summary>
    /// 初始化弃牌区卡牌的本地起始位置和状态。
    /// </summary>
    private void InitializeDiscardArea()
    {
        if (discardCard == null) return;
        const float INITIAL_Y_OFFSET = 5f;

        Transform discardTransform = discardCard.transform;
        Vector3 targetPos = GetDiscardTargetPosition();
        Vector3 startPosLocal = targetPos - new Vector3(0, INITIAL_Y_OFFSET, 0);

        discardTransform.localPosition = startPosLocal;
        discardTransform.localEulerAngles = Vector3.zero;
        discardCard.color = new Color(1, 1, 1, 0);
    }

    /// <summary>
    /// 初始化回撤按钮：将其设置为完全透明，并禁用交互。
    /// </summary>
    private void InitializeRecallButton()
    {
        if (recallButton == null) return;
        CanvasGroup cg = recallButton.GetComponent<CanvasGroup>();
        if (cg != null)
        {
            cg.alpha = 0f;
            cg.interactable = false;
            cg.blocksRaycasts = false;
        }
        recallButton.gameObject.SetActive(false);
    }

    /// <summary>
    /// 创建主卡牌的入场动画。
    /// </summary>
    private Tween CreateCardTween(int cardIndex, float duration)
    {
        Transform cardTransform = listPokers[cardIndex - 1].transform;
        SpriteRenderer cardRenderer = listPokers[cardIndex - 1];
        Vector3 targetPos = targetPositions[cardIndex];

        Sequence cardSequence = DOTween.Sequence();
        Tween moveTween = cardTransform.DOMove(targetPos, duration).SetEase(Ease.OutSine);
        Tween finalRotate = cardTransform.DOLocalRotate(Vector3.zero, duration, RotateMode.Fast).SetEase(Ease.InOutQuad);
        Tween fadeTween = cardRenderer.DOFade(1f, duration * 0.5f);

        cardSequence.Append(moveTween);
        cardSequence.Join(finalRotate);
        cardSequence.Join(fadeTween);

        return cardSequence;
    }

    /// <summary>
    /// 创建左侧牌区的连续堆叠入场动画。
    /// </summary>
    private Sequence AnimateLeftArea()
    {
        Sequence leftSequence = DOTween.Sequence();
        if (listLeftPokers == null || listLeftPokers.Count == 0) return leftSequence;

        float aggressiveOverlapLeft = -(leftAnimationDuration - 0.1f);

        for (int i = 0; i < listLeftPokers.Count; i++)
        {
            Transform cardTransform = listLeftPokers[i].transform;
            SpriteRenderer cardRenderer = listLeftPokers[i];
            Vector3 targetPos = GetLeftPokerTargetPosition(i);

            Tween moveTween = cardTransform.DOLocalMove(targetPos, leftAnimationDuration).SetEase(Ease.OutBack);
            Tween fadeTween = cardRenderer.DOFade(1f, leftAnimationDuration * 0.5f);

            Sequence cardEntry = DOTween.Sequence().Append(moveTween).Join(fadeTween);

            leftSequence.Append(cardEntry);

            if (i < listLeftPokers.Count - 1)
            {
                leftSequence.AppendInterval(aggressiveOverlapLeft);
            }
        }

        return leftSequence;
    }

    /// <summary>
    /// 创建弃牌区卡牌的入场动画。
    /// </summary>
    private Tween AnimateDiscardArea()
    {
        if (discardCard == null) return DOTween.Sequence();

        Transform discardTransform = discardCard.transform;
        Vector3 targetPos = GetDiscardTargetPosition();

        Tween moveTween = discardTransform.DOLocalMove(targetPos, leftAnimationDuration).SetEase(Ease.OutBack);
        Tween fadeTween = discardCard.DOFade(1f, leftAnimationDuration * 0.5f);

        return DOTween.Sequence().Append(moveTween).Join(fadeTween);
    }

    /// <summary>
    /// 创建回撤按钮的淡入动画，并启用交互。
    /// </summary>
    private Tween AnimateRecallButton()
    {
        if (recallButton == null) return DOTween.Sequence();

        CanvasGroup cg = recallButton.GetComponent<CanvasGroup>();
        if (cg != null)
        {
            recallButton.gameObject.SetActive(true);

            return cg.DOFade(1f, 0.3f)
                     .OnComplete(() => {
                         cg.interactable = true;
                         cg.blocksRaycasts = true;
                     });
        }
        else
        {
            Debug.LogError("回撤按钮上缺少 CanvasGroup 组件！");
            return DOTween.Sequence();
        }
    }

    /// <summary>
    /// 启动所有卡牌和 UI 元素的入场动画序列。
    /// </summary>
    private void StartEnterAnimationSequence()
    {
        Sequence enterSequence = DOTween.Sequence();
        float aggressiveOverlap = -(animationDuration - 0.3f);

        // 主卡牌入场序列
        enterSequence.Append(CreateCardTween(1, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(7, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(2, animationDuration)).Join(CreateCardTween(8, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(3, animationDuration)).Join(CreateCardTween(9, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);

        int[] leftSide = { 10, 11, 12, 13 };
        int[] rightSide = { 14, 15, 16, 17 };
        for (int i = 0; i < leftSide.Length; i++)
        {
            enterSequence.Append(CreateCardTween(leftSide[i], animationDuration)).Join(CreateCardTween(rightSide[i], animationDuration));
            enterSequence.AppendInterval(aggressiveOverlap);
        }

        enterSequence.Append(CreateCardTween(4, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(5, animationDuration));
        enterSequence.AppendInterval(aggressiveOverlap);
        enterSequence.Append(CreateCardTween(6, animationDuration));

        // UI 元素入场序列
        enterSequence.AppendInterval(0.8f);
        enterSequence.Append(AnimateLeftArea());
        enterSequence.AppendInterval(0.3f);
        enterSequence.Append(AnimateDiscardArea());
        enterSequence.AppendInterval(recallButtonFadeDelay);
        enterSequence.Append(AnimateRecallButton());

        enterSequence.OnComplete(() =>
        {
            Debug.Log("所有 UI 元素入场动画序列完成！现在可以开始交互操作，并记录最终位置。");

            // 【关键修复】：动画完成后，通知所有卡牌记录它们当前的位置
            foreach (CardData card in allCardData)
            {
                card.FinalizeInitialState();
            }
        });
    }
}

using System.Collections.Generic;
using UnityEngine;
using DG.Tweening;

public class CardInteractionManager : MonoBehaviour
{
    // ====== 引用和参数 ======
    [SerializeField] private Transform recallButton;
    [SerializeField] private float interactionDuration = 0.3f;

    [Tooltip("弃牌堆的基准世界坐标。")]
    [SerializeField] private Vector3 discardWorldBasePosition;

    private const float STACK_Z_OFFSET = 0.05f;

    private Stack<CardData> discardStack = new Stack<CardData>();
    private List<CardData> leftStackCards = new List<CardData>();

    // ================== 初始化和状态管理 ==================

    void Start()
    {
        CardData[] allCards = FindObjectsOfType<CardData>();

        foreach (CardData card in allCards)
        {
            // 确保所有卡牌的 Collider 默认禁用
            Collider cardCollider = card.GetComponent<Collider>();
            if (cardCollider != null)
            {
                cardCollider.enabled = false;
            }

            if (card.type == CardType.LeftHandCard)
            {
                leftStackCards.Add(card);
            }
        }

        // 排序左手牌列表 (依据 stackIndex)
        leftStackCards.Sort((a, b) => a.stackIndex.CompareTo(b.stackIndex));

        // 启用初始可点击的卡牌碰撞体

        // FieldCard 默认启用
        foreach (CardData card in allCards)
        {
            if (card.type == CardType.FieldCard)
            {
                Collider fieldCollider = card.GetComponent<Collider>();
                if (fieldCollider != null)
                {
                    fieldCollider.enabled = true;
                }
            }
        }

        // 启用左手牌堆的顶层卡牌
        if (leftStackCards.Count > 0)
        {
            CardData topCard = leftStackCards[leftStackCards.Count - 1];
            Collider topCollider = topCard.GetComponent<Collider>();
            if (topCollider != null)
            {
                topCollider.enabled = true;
            }
        }
    }

    // ================== 点击处理 (3D Raycast) ==================

    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            HandleClick();
        }
    }

    private void HandleClick()
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        if (Physics.Raycast(ray, out RaycastHit hit))
        {
            CardData card = hit.collider.GetComponent<CardData>();

            if (card != null)
            {
                if (IsCardClickable(card))
                {
                    MoveCardToRightHand(card);
                }
            }
            // 检测是否点击了回撤按钮
            else if (hit.transform == recallButton)
            {
                if (discardStack.Count > 0)
                {
                    RecallLastCard();
                }
            }
        }
    }

    private bool IsCardClickable(CardData card)
    {
        // 核心检查：碰撞体必须启用
        Collider cardCollider = card.GetComponent<Collider>();
        if (cardCollider == null || !cardCollider.enabled) return false;

        if (card.type == CardType.FieldCard)
        {
            // 场内牌逻辑：检查所有阻挡牌是否已被清除
            foreach (CardData blocker in card.BlockerCards)
            {
                Collider blockerCollider = blocker.GetComponent<Collider>();
                if (blockerCollider != null && blockerCollider.enabled)
                {
                    return false;
                }
            }
            return true;
        }
        else if (card.type == CardType.LeftHandCard)
        {
            // 左手牌逻辑：只有列表中的最后一张（顶层卡牌）可点击
            if (leftStackCards.Count == 0) return false;
            return card == leftStackCards[leftStackCards.Count - 1];
        }

        return false;
    }

    private void MoveCardToRightHand(CardData card)
    {
        if (!IsCardClickable(card)) return;

        // 计算本地目标位置
        Transform cardParent = card.transform.parent;
        Vector3 targetBaseLocalPos = (cardParent != null) ?
                                     cardParent.InverseTransformPoint(discardWorldBasePosition) :
                                     discardWorldBasePosition;

        // Tip 隐藏逻辑 1：禁用前一张卡牌的 Tip
        if (discardStack.Count > 0)
        {
            CardData previousTopCard = discardStack.Peek();
            if (previousTopCard.CardTip != null && previousTopCard.CardTip.gameObject != null)
            {
                previousTopCard.CardTip.gameObject.SetActive(false);
            }
        }

        int currentStackCount = discardStack.Count;
        float newZ = targetBaseLocalPos.z + (currentStackCount * STACK_Z_OFFSET);
        Vector3 dynamicTargetLocalPos = new Vector3(targetBaseLocalPos.x, targetBaseLocalPos.y, newZ);

        SpriteRenderer cardRenderer = card.GetComponent<SpriteRenderer>();
        if (cardRenderer != null)
        {
            cardRenderer.sortingOrder = currentStackCount;
            cardRenderer.DOFade(1f, 0.1f);
        }

        // Tip 文本逻辑：移动 Tip 到新卡牌的动态位置
        if (card.CardTip != null && card.CardTip.gameObject != null)
        {
            card.CardTip.gameObject.SetActive(true);
            Vector3 tipTargetLocalPos = dynamicTargetLocalPos;
            tipTargetLocalPos.z += 0.01f;
            card.CardTip.transform.DOLocalMove(tipTargetLocalPos, interactionDuration).SetEase(Ease.InOutSine);
            card.CardTip.DOFade(1f, 0.1f);
        }

        if (card.type == CardType.FieldCard)
        {
            AnimateFieldToDiscard(card.transform, dynamicTargetLocalPos);
        }
        else if (card.type == CardType.LeftHandCard)
        {
            AnimateLeftToDiscard(card.transform, dynamicTargetLocalPos);
            // 移除被点击的左手牌
            if (leftStackCards.Count > 0)
            {
                leftStackCards.RemoveAt(leftStackCards.Count - 1);
            }
        }

        // 禁用当前卡牌的碰撞体并入栈
        Collider cardCollider = card.GetComponent<Collider>();
        if (cardCollider != null) cardCollider.enabled = false;
        discardStack.Push(card);

        // 启用新的顶层左手牌的碰撞体
        if (card.type == CardType.LeftHandCard && leftStackCards.Count > 0)
        {
            CardData newTopCard = leftStackCards[leftStackCards.Count - 1];
            Collider newTopCollider = newTopCard.GetComponent<Collider>();
            if (newTopCollider != null)
            {
                newTopCollider.enabled = true;
            }
        }
    }

    private void AnimateFieldToDiscard(Transform cardTransform, Vector3 targetLocalPos)
    {
        cardTransform.DOLocalMove(targetLocalPos, interactionDuration).SetEase(Ease.InOutSine);
    }

    private void AnimateLeftToDiscard(Transform cardTransform, Vector3 targetLocalPos)
    {
        Sequence flipAndMove = DOTween.Sequence();
        float halfDuration = interactionDuration * 0.5f;

        // 旋转 180 度到背面朝上
        Tween finalRotate = cardTransform.DOLocalRotate(new Vector3(0, 180f, 0), halfDuration, RotateMode.Fast).SetEase(Ease.InOutQuad);

        flipAndMove.Append(cardTransform.DOLocalMove(targetLocalPos, interactionDuration).SetEase(Ease.InOutSine));
        flipAndMove.Join(finalRotate);
    }

    // ================== 回撤逻辑 ==================
    private void RecallLastCard()
    {
        if (discardStack.Count == 0) return;

        CardData cardToRecall = discardStack.Pop();
        Transform cardTransform = cardToRecall.transform;

        // 目标位置：卡牌入场动画结束时的稳定本地位置 (这里现在依赖 CardData 中的修复)
        Vector3 endLocalPos = cardToRecall.initialLocalPosition;

        // 启用碰撞体
        Collider recallCollider = cardToRecall.GetComponent<Collider>();
        if (recallCollider != null) recallCollider.enabled = true;

        // Tip 逻辑：隐藏回撤卡牌的 Tip
        if (cardToRecall.CardTip != null && cardToRecall.CardTip.gameObject != null)
        {
            cardToRecall.CardTip.gameObject.SetActive(false);
        }

        // Tip 逻辑：显示新的顶层 Tip (如果存在)
        if (discardStack.Count > 0)
        {
            CardData newTopCard = discardStack.Peek();
            if (newTopCard.CardTip != null && newTopCard.CardTip.gameObject.activeSelf == false)
            {
                newTopCard.CardTip.gameObject.SetActive(true);
                newTopCard.CardTip.DOFade(1f, 0.1f);
            }
        }

        // 创建动画序列
        Sequence recallSequence = DOTween.Sequence();

        // 动画：移动回初始位置
        recallSequence.Append(
            cardTransform.DOLocalMove(endLocalPos, interactionDuration).SetEase(Ease.OutBack)
        );

        if (cardToRecall.type == CardType.LeftHandCard)
        {
            // 恢复旋转：从 180 度转回 0 度（正面朝上）
            Tween reverseRotate = cardTransform.DOLocalRotate(Vector3.zero, interactionDuration, RotateMode.Fast).SetEase(Ease.OutSine);
            recallSequence.Join(reverseRotate);

            // 恢复逻辑列表并排序
            leftStackCards.Add(cardToRecall);
            leftStackCards.Sort((a, b) => a.stackIndex.CompareTo(b.stackIndex));
        }

        // 最终淡入动画 (所有卡牌)
        SpriteRenderer cardRenderer = cardTransform.GetComponent<SpriteRenderer>();
        if (cardRenderer != null) cardRenderer.DOFade(1f, 0.2f);
    }
}
